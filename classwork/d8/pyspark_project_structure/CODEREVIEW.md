## Code Review

### С чего начать? Давайте разберем процесс и рассмотрим каждый шаг:

#### 1 Мой ToDo

В проекте должен быть **«пост»ToDo** файл с прописанными шагами и простым описанием каждого файла и каталога, который поддерживает данный разработчик. В файле заполняются шаги, что и для чего сделано.

Но! Ревьюер должен иметь такой же файл для своей работы, в виде комментариев для себя. В ревьюер _ToDo_ хорошо описывать последовательность ревью и что и когда смотреть.

**Свой пример**: в результате отработки таких ToDo'шек, на данный момент, я составляю сгруппированный список из нескольких больших элементов, которые содержат 2 – 3 маленькие подзадачи. 

Наличие списка для поиска - это конечный список дел, который становится маршрутом по коду вашего коллеги, это лучше, чем бездумно гулять по ветвлениям чужого кода.

```ToDo
### Code Review ToDo (by Seleznev)
// file | task | additional
1. job_runner.py | проверить набор функций по работе с витриной | -> TEST 1, 2
2. config.json   | добавлен новый файл конфигурации, проверить наличие ключей | -> TEST 3, 4
…et

### TEST
// main job | wh? | additional
1. step 1 | тестирование на hql | -
2. step 1 | проверить правильность коннектера к данным
3. step 2 | проверить правильность работы с json в файлах
4. step 2 | подходит ли json, почему не yaml или др.форматы | уточнить у архитектора
…et
```

#### 2 Шаблоны замечаний

Стоит заранее подготовить шаблонные фразы для тех мест, где код может быть улучшен. Сделать это стоит заранее и приготовить 2 – 3 фразы, которые будут описывать код, дадут старт к рассуждениям и укажут на недостаток. 

**Свой пример**: у меня есть фразы, начинающаяся со слов «**_Что есть исправить…_**»; или если вариантов решения много, а точного улучшения не ожидается «**_Тут возможны варианты улучшения, давайте поразмышляем о …_**»

**Особенность**: при дальнейшей работе с замечаниям по коду, стоит выбирать решение, которое основывается на меньшем количестве предположений, то есть самое просто (можно ознакомиться с принципом «__Бритва Оккама__» и попробовать проецировать его на код)

**Важно 1**: В замечаниях по коду не используем "свой авторитет", особенно, если у вас выше должность! Вместо того, чтобы говорить _"Эта функция не должна содержать в себе ..."_. Необходимо рекомендовать или создавать посыл к поиску решений: _" Так как в функции нет состояний ХХХ, то содержание .... можно сделать компонентом. Это улучшит ... и читабельность. Можно обратиться к документации **ССЫЛКА** и **примеру из кода Х**."_

**Важно 2 _Мастер одной ошибки_**: Часто в коде можно найти одну ошибку несколько раз, не стоит указывать на неё везде. Сделайте 1 комментарий в месте первого обнаружения и 1 комментарий в повторном, но уже указав, что эта ошибка имеет неоднократный повтор.  

**Важно 3**: Нет осуждению в работе и комментария. Не надо писать: "_Сделай это так, как нормальный разраб__". Только с комментариями и объяснениями: "_Сделаем это вот так вот, это будет нам полезно потому ..._"

**Важно 4**: Стоп сарказм! Часто эти комментарии пишут не из-за того, что имеют/обладают чувством юмора, а из "развязности" или отсутствие чувства такта в команде. Такие комментарии не несут в себе информацию, а лишь способствуют "уничтожению / занижению" процесса код ревью. Переходя на сарказм, всегда помните, что вы его используете ВСЕГДА! на тех коллегах, которых вы считаете чем-то хуже вас (статус, должность, умения и навыки). Помните, что вы не будете использовать его на встрече у руководителя, топ-менеджера и т.п. Все ещё используете сарказм? Помните: больше **83%** мастеров - сарказма не могут выступить публично, боятся публичного осуждения и не могут генерировать новые идеи, а лишь копируют (повторяют) материал. Люди, использующие сарказм, часто являются _"токсичными"_ и мешают работать команде.

#### 3 Договоритесь о форматировании кода

Работать с кодом будет удобней, если будет единый стиль форматирования и он будет одинаков (_максимально похож_) для всех используемых языков. В этом пункте DS | DA повезло больше всех, так как их языковой инструментарий (Python, R, Scala) позволяет выработать универсальный стиль.

В этот пункт включаем и найминг перемененных:
• либо везде второе слово с большой: `_theVariable_`
• либо верблюжий: `_TheVariable_`
• либо змеиный: `_the_variable_`
и т.д.

**Стиль комментирования**:

Договоримся о комментировании: выделите обязательные места, где должны быть комментарии. `Самые популярные места`: начало класса, начало функции, перед большой обработкой значений, перед визуализацией.
Как ни странно, но лучше договорится о варианте комментирования: _строчные_ (`#`, `//`, `--`) или _многострочные_ (`/**/`) оформления комментариев (**_я выбираю многострочные_**) 

**Важно запомнить**, что комментарии должны включать в себя информацию которая описывает не только «что вы делаете», но и почему вы это делаете. Часть «что вы делаете» должна пересекаться с ToDo

#### 4 Вспомните алгоритмы

Не забываем о алгоритмах, которые можно использовать (**_в библиотеке вашей команды должны появится книги: Тим Рафгарден: Совершенный алгоритм | Кормена. Лейзерсона. Ривеста.: Алгоритм - построение и анализ_**)

**Пример**: если вы знаете, что работаете с числовыми значения, на входе у вас всегда список из int / float, а на выходе обработанные значения из этого списка, которые больше, чем n. А ваш коллега решил искать значения через цикл, то исправьте это.

```Python
"""
   Вы увидели код,
   valueList - всегда список числовых значений
   trigger - float значение, если значние в valueList больше или равно trigger, совершается действие
"""
# Было
for i in valueList:
     if i >= trigger:
          # action

# Что если огранить список зарание и отсортировать его. 
# Мы уменьшем количество опираций в цикле for

# Будет
valueList = sorted(valueList, key=lambda x: x >= trigger)
# action
```

#### 5 Используйте возможности языка

Используйте все возможности языка и при его обновлении переходите на новые версии в своих экспериментах. Этот пункт зависим от взаимообучения в команде, так как нужна группа людей, которая всецело должна быть евангилистами языка.

```Python
""" 
   Ещё можно увидеть, как создают дополнительный счетчик и используют его
   Задача: создать список из кортежей с именем и характеристиками, сортировка по убыванию
   [('name', i, parameter)]
"""

# Создано с самодельным счетчиком
val = 0
for name in workers:
   # action
   val += 1

# используем возможности языка
result = [(worker.age, i, worker) for i, worker in enumerate(workers)]
result.sort()
result = [worker for age, i, worker in result]
```

Еще пример, изменит декоратор нашего коллеги

```Python
""" 
   Коллега пишет декоратор, который считает вызовы и делает обработку
   
   Здесь можно будет вспомнить, что function - это экземпляр класса и он содержит атрибуты.
"""

# Было
def counter(func):
    """
    Декоратор, считающий и выводящий количество вызовов
    """
 
    if not hasattr(counter, 'count'):
        counter.count = {}
 
    counter.count[func.__name__] = 0
    def wrapper(*args, **kwargs):
        counter.count[func.__name__] += 1
	
        # action
	
        return res
    return wrapper

# Возможно стоит заглянуть в функцию и посмотреть, какими атрибутами она обладает
# Рассмотри варианты подсчета с помощью invocation_count
def counter(func):
    """
    Декоратор, считающий и выводящий количество вызовов
    """
 
    func.__invocation_count__ = 0
 
    def wrapper(*args, **kwargs):
        func.__invocation_count__ += 1
        
	# action
	
        return res
    return wrapper

```

**Важно!** не заиграйтесь с возможностями языка! на примерах был Python, но на других языках, которые использую DS | DA, возможности языка могут сделать его не очень читаймым (на пример Scala, пример ниже)

```Scala
def initH = INDArrayLayer(Nd4j.zeros(hiddenSize, 1).forward)
     def singleRound(initprevloss: Losses): Future[Losses] =
          (batches.foldLeftM((initprevloss, initH)) {
          (bstate: WithHiddenLayer[Losses], batch: Batch) =>
              bstate match {
                  case (prevloss, hprev) => singleBatch(batch, hprev) match {
                  case (bloss, hnext) => bloss.train.map {
                       (blossval: Double) => {
                           val nloss = prevloss.last * 0.999 + blossval * 0.001
                           val loss_seq = prevloss :+ prevloss.last * 0.999 + blossval * 0.001
                           (loss_seq, hnext)
                                             }
                            }
                    }
              }
         }).map {
                 (fstate: WithHiddenLayer[Losses]) =>
                 fstate match {
                               case (floss, _) => floss
                }
           }
```


#### 6 Не повторяемость кода (DRY code – do not repeat yourself)

Если код, который вы видите повторяется 2 и более раза. Напишите комментарий, что эту часть надо убрать и сделать функцией или компонентом.
Невозможно сделать функцией? Переосмыслите этот отрезок кода.

```SQL
/*
   Используем with, как способ не повторения кода
*/

-- было
SELECT DISTINCT
      yo.snap_date
      , yo.user_id
      , yo.amb_id
      , yo.amb_name
FROM
    tbl.you_ambitions yo
LEFT JOIN
    opt.target t
       ON t.trg in (SELECT DISTINCT yo.amb_id FROM tbl.you_ambitions yo WHERE 1 = 1 AND yo.amb_trg = 1)
WHERE
     1 = 1
  AND
     yo.amb_trg = 1
    
-- Уберем в WITH
-- Коллега, повторяющиеся селекты используем в WITH

-- будет замена на WITH 
WITH amb
AS (SELECT --+ MATERIALIZED
           DISTINCT
           yo.snap_date
           , yo.user_id
           , yo.amb_id
      	   , yo.amb_name
    FROM
        tbl.you_ambitions yo
    WHERE
         1 = 1
      AND
         yo.amb_trg = 1
)

..etc
```

#### 7 Лимит глубины условий

DS | DA играясь с условиями и циклами в Python могут уходить довольно глубоко, но конечный результат может не быть доступен. Стоит в своем код стайле описать глубину возможного (я практикую не более 3, если надо больше условий – то нужен другой подход, а если это цикл, то не больше 2 (что уже много!) )

```Python
"""
   При содании train / test рейтингов
   используется множестванная переборка и работа соспискам
"""

# плохой пример
factY = []
predY = []

for (user, itemsRating) in userItemRecs:
    for (rating, item) in itemsRating:
        for (testItem, testRating) in testRating[user]:
	    if testItem == item:
	        #action
		
# Использовать 2 вложенных цикла в 1 цикл довольно плохая идея
# Коллега, у нас есть возможность сократить вложенность, тем самым мы ускорим время выполнения?

```

##### 7.1 Не надо работать со всеми элементами и помните о сложности O(n)

Вы можете найти куски кода, где идет опрос каждого элемента! Но это ужасно:

- представьте себе, что вы сидите за рабочим столом, а ваш босс обращается к вам, но чтобы узнать вы это или нет, он проходит всех по часовой стрелке. Вы будете долго ждать, пока он обратиться к Вам.

В одном из учебных заданий был вопрос: _а как правильно написать?_

```Python
m=[i for i in range(346) if i>101]
print(*m)

или

a=range(346)
b=filter(lambda x: x>101,a)
print(*b)
```

Здесь нужно ответить, что оба варианта не лучшее решение! Так как, решение для 346 элементов - ок, а когда будете работать на реальных данных? Решите это правильно

```Python
a = range(346)
b = a[a.index(101)+1 : ]
print(*b)
```


#### 8 Файл конфигурации

В проектах DS | DA часто используются конфигурации, настройки и прочее. Не стоит их повторять в коде настройки алгоритмов, пути к файлам и когда запросов к БД, используйте для этого конфигурационные файл в json или yaml форматах.

Это удобно и позволяет версионировать код и результаты эксперимента.


#### 9 Список рекомендаций

**Запомним**: Не смотря на любые призывы, люди `не любят` или боятся заниматься критикой коллег, особенно если этот коллега **_HiPP_** (высоко оплачиваемая персона, звезда компании и т.д.). Сгладить этот процесс поможет составление списка в комментариях к коду, до и после ревью: главные 5 вещей, которые стоит сделать в следующий раз и 5 вещей, которые не стоит использовать в проекте (по причинам).

Происходит выравнивание негатива позитивными решениям.

